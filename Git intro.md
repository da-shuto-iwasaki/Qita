
# 【Git入門】

<b>　GitやGithubを使ってはいるが、結局どこがどのように良いのかいまいちわかっていない、という状態を脱却するために、まとめることにする。<br>
　※参考は[バージョン管理システム入門(初心者向け)by tracpath](https://tracpath.com/bootcamp/learning_git_firststep.html)</b>

***

## ◯共有リポジトリ

<img src=https://tracpath.com/bootcamp/wp-content/themes/_btcp/images/git_fig1.jpg>

<b>　ここで、共有リポジトリに関していくつかのキーワードを説明する。
- 作業ディレクトリ:<br>
共有リポジトリから取得したローカル環境のリポジトリであり、自由に追加・編集が可能。gitを使った開発では、この作業ディレクトリ上で開発を進める事になる。
- コミット:<br>
新規作成したファイルや編集したファイルを保存すること。作業ディレクトリ上で一区切りついた際にコミットする事でそれまでの作業を一旦保存する。</b>

***

## ◯gitを使った作業の流れ

<img src=https://tracpath.com/bootcamp/wp-content/themes/_btcp/images/git_fig3.jpg>

<b>
1. 作業ディレクトリ(Working Directory)
<br>共有リポジトリと同じファイルがローカルに展開され、ファイルの追加修正を行うディレクトリのこと。
2. 索引(Index)
<br>コミット予定のファイル群を索引に追加し、記録する。この操作は、「ステージング」「コミット予定」「管理対象」と呼ばれる。
3. HEAD
<br>作業最後のコミットのこと。また、gitは作業ディレクトリでコミットが行われるとmaster ブランチと呼ばれる作業ディレクトリを作る。master ブランチは直近のコミットを指し示す意味を持っている。

コミットを作業ディレクトリで実行し、[master]ブランチが新しいコミットに移動する。
</b>

***

## ◯リポジトリの作成とクローン

<b>　これまでのgitを使った作業の流れをコマンドで見る。まずは、共有リポジトリを作成する。以下のコマンドを打つ事で、初期リポジトリが作成できる。</b>

`$ git init`

<b>　通常は複数メンバーで開発を進める事になるため、共有リポジトリを利用する場合多い。その場合は、クローン（clone）をして作業ディレクトリをローカルに作成する。</b>

`$git clone https:// [username] @ [domain/path/to/repository
]`

***

## ◯ファイルの追加＆コミット

<b>　作業ディレクトリで変更したファイルを索引に追加する。（コミット準備、管理対処にする。）</b>

`$ git add <filename>`

<b>　これにより、編集したファイルが索引に追加された。それでは、この変更内容をコミットする。</b>

`$ git commit -m "なんかコメント"`

<b>　これで、変更内容が索引からコミットされ、HEADに格納された。ただし、<font color="Red">まだ共有リポジトリには反映されていない</font>ことに注意！</b>

***

## ◯共有リポジトリにプッシュする

<b>　変更内容を共有リポジトリに反映させるには、以下の push コマンドを打つ。</b>

`$ git push origin master`
><b>`master` ブランチにコミットされた HEAD の内容を共有リポジトリ `origin` に送信</b>

`$ git push origin`
><b>プッシュ( push )して共有リポジトリ `origin` に作業ディレクトリのコミットをする</b>

<b>　ここで、プッシュ (push) したところまでのコミットが共有リポジトリに反映されることになる。</b>

<img src=https://tracpath.com/bootcamp/wp-content/themes/_btcp/images/git_fig7.jpg>

<b>　ローカルでリポジトリを作成（ `git init` ）や、共有リポジトリからクローン（ `clone` ）していない場合、共有リポジトリを登録することができる。</b>

`$ git remote add origin <server>`

***

## ◯共有リポジトリから最新をプルし、マージする

<b>　他のメンバーが追加した機能や修正したファイルを自分の作業ディレクトリに取り組むことが可能この作業をプル（ pull ）という。</b>

<img src=https://tracpath.com/bootcamp/wp-content/themes/_btcp/images/git_fig8.jpg>

<b>　つまり、プル（ pull ）とは、共有リポジトリの最新情報を取得（ fetch ）し、自分の作業ディレクトリと統合（ merge ）することを意味している。</b>

`$ git pull`

***

# ◯分散バージョン管理によるチーム開発の流れ

<b>　ここまでが必要最低限必要な知識である。ここから、共同開発で必ず必要になるブランチについて説明する。</b>

***

## ◯ブランチ

<b>　今まで考えていたのは全て `master` ブランチである。しかし、例えば今までと全く異なるロジックを思いついたが性能がどうなるかわからない、という状況を考える。すると、実際に試してみたいが、結果がわかる前に共有リポジトリに反映させたくはない。<br>
　このような場合に利用するのが一般的なブランチの利用方法である。</b>

<img src=https://tracpath.com/bootcamp/wp-content/themes/_btcp/images/git_fig9.jpg>

***

## ◯ブランチの基本とマージ

<b>　それでは実際の開発例として、以下のような状況を考える。
>あるチームが作っているアプリケーションはすでにバージョン$1.0$が本番環境でエンドユーザーに提供されている。開発チームは新たな機能を取り入れたバージョン$2.0$の開発に取り組んでいたが、バージョン$1.0$に重大なバグが発見された。開発チームは早急にそのバグに対応しなくてはならない。</b>

<b>
【開発の流れ】
1. リリースされたバージョン1.0が稼働している
1. 開発チームは新しいブランチを作成し、バージョン2.0の開発を実施中
1. すでにバージョン2.0の開発は進んでいる時に、本番稼働しているバージョン1.0に重大な障害がみつかり、早急に対応が必要となった
1. バージョン2.0のブランチをバージョン1.0のブランチに変更する
1. 修正適用のためのブランチを1.0から作成する
1. 修正用ブランチで問題を解決し、修正用ブランチをバージョン1.0のブランチにマージする。新しいバージョン1.1ができる
1. マージしたバージョン1.1を共有リポジトリにプッシュ(push)する
1. 問題の解決後、作業途中のバージョン2.0 ブランチに戻り開発を継続する
</b>

<b>　これらについて細かく見ていくことはしないので、詳しくは[参考](https://tracpath.com/bootcamp/learning_git_firststep.html)を参照。</b>

***

## ◯マージの基本

<b>　マージはとても機能が多く、よく理解していないと履歴の損失などのリポジトリ破壊をもたらす可能性がある。そのため、マージ/リベース(rebase)操作を実行するユーザを特定の人に制限するという方針をとることもよくある。</b>

<b>　マージ(merge)は枝分かれしたブランチを１つに統合することを言う。コミットされる度にブランチは１つずつ版を重ねていくが、コミットは１ファイルだけではなく複数のファイルが含まれている。そのため、マージ処理とは、
1. 同一ファイルに行われた変更を統合する。
2. コミットに含まれるファイル全体を統合する。

ことを意味している。また、マージ処理には大きく以下の3パターンがある。
1. ファストフォワード(Fast-Foward)
2. ファストフォワードしないマージ（Non Fast-Forward）
3. リベース(rebase)</b>

***

### 1. ファストフォワード（Fast-Forward）

<b>　ファストフォワード(Fast-Forward)は、「早送り」と言う意味である。</b>

<img src=https://tracpath.com/bootcamp/wp-content/themes/_btcp/images/git_project10.jpg>

<b>　上は、`master` をチェックアウトしている状態である。この状態で `bugfix` をマージする。</b>

`$ git merge bugfix`

<img src=https://tracpath.com/bootcamp/wp-content/themes/_btcp/images/git_project11.jpg>

<b>　「c6」が「master」にマージされて、「master」が「c6」に移動した。マージしたが新しいコミットは作られず、ブランチの位置が移動しただけである。このため、「早送り」と言う名前で呼ばれている。</b>

***

### 2. ファストフォワードしないマージ（Non Fast-Forward）

<img src=https://tracpath.com/bootcamp/wp-content/themes/_btcp/images/git_project12.jpg>

`$ git merge new-2.0`

<img src=https://tracpath.com/bootcamp/wp-content/themes/_btcp/images/git_project13.jpg>

<b>　上記のように、マージによって新しいコミット「c7」ができた。ファストフォワードしないマージは、早送りと違って新しいコミットを作成し枝分かれした履歴を保持したまま「c7」を作成する。</b>

<b>　全く同じコマンドを打っているように見えるが、この辺りはgitが賢く動作をしてくれる。明示的にコマンドを打つなら、以下のようにする。</b>

`git merge <branch-name>`<br>
<b>#早送り(Fast-Forward)できればする、無理なら普通(Non Fast-Forward)のマージ</b><br>
`git merge --no-ff <branch-name>`<br>
<b>#普通の(Non Fast-Forward)マージ</b><br>
`git merge --ff-only <branch-name>`<br>
<b>#早送り(Fast-Forward)マージ</b>

***

### 3. リベース（rebase）

<img src=https://tracpath.com/bootcamp/wp-content/themes/_btcp/images/git_project14.jpg>

<b>　ここでマージを実行すると、Fast-Forward になって「c7」を生成する。では、リベース（rebase）するとどうなるのか？</b>

<img src=https://tracpath.com/bootcamp/wp-content/themes/_btcp/images/git_project15.jpg>

<b>　想定シナリオとして本番稼働して「master」ブランチのバグ対応版である「c6」を取り込んだ上で、「new-2.0」ブランチの開発を継続した。</b>

<b>【動作のまとめ】
1. 「c3」の差分をパッチ(3)にする
1. 「c4」の差分をパッチ(4)にする
1. 「c5」の差分をパッチ(5)にする
1. 「new-2.0」ブランチを「c2」から「c6」に移動
1. パッチ(3)を適用して、「c3’」
1. パッチ(4)を適用して、「c4’」
1. パッチ(5)を提供して、「c5’」
</b>

<b>　枝分かれしている元を再指定しているので、リベース（rebase）となる。<br>
　リベースは、ローカルにのみ存在するブランチに対して操作する方が良い。と言うのも、上の例で言えば、共有リポジトリを使っている場合、ブランチ「new-2.0」は複数メンバーで共有されている可能性が高いため、リベースしてしまうと共有リポジトリに push できなくなるからである。強制的に上書きすることは可能だが、版の履歴がなくなってしまう。<br>
　これらの理由から、共有リポジトリではリベースしない、と言うルールを作った方が良い。</b>

***

## ◯コンフリクト

<b>　マージを行うと、コンフリクト（衝突）が発生する場合がある。衝突とは、マージを実行した時に「同じファイルの同じ行に違う変更をしていた」ブランチ同士をマージした場合を言う。このような場合には、どちらのブランチを採用するか、利用者が判断する必要がある。</b>

<b>　なお、git はコンフリクトが発生したときコンフリクトが解決するまで処理を停止する。（マージは正常に終わっていないことになる。）また、どこのソースコードでコンフリクトが発生したのか、詳細な情報を見ることが可能である。</b>

`$ git status`

<b>　`git status` コマンドでマージ失敗したソースコードを確認し、手作業で修正を行う。また、<font color="Red">コンフリクトを解決して一安心しても作業終了ではない。</font><br>
　修正したソースコードに対して索引(index)に追加する必要がある。(`git add`)  index に追加して git にコンフリクトを修正したことを通知する。最後にコミットを実行して、コンフリクトは解決する。</b>
